- [x] Make A Skip List
	- [x] Create nodes :: SkipListSetItems
		- [x] Contains payload, left, right, up, and down pointers, and height of node
	- [x] Create a layering system
		- [x] An ArrayList containing the head nodes of every level
		- [x] A second ArrayList keeping track of how many nodes are at every level, updated after an insertion or deletion
		- [x] Set a minimum number of layers
		- [x] Hold the current number of layers
			- [x] Update the current amount of layers to log2n upon insertion or deletion, letting the minimum number of layers override the results of this calculation
	- [x] Implement core skip list functionality :: SkipListSet
		- [x] Search
			- [x] Start at the head node pointed to by the last element of the ArrayList layering system
			- [x] Go through the linked list until we find a value larger than the node we’re looking for
			- [x] Go back a node, traverse down, repeat previous step until we find the value or have reached the bottom layer without finding it
		- [x] Insert
			- [x] Use previous traversal logic from search to find the node in the base layer we want to insert after
			- [x] Add our new node to a random height of layers
			- [x] Ensure all pointers are correct
		- [x] Delete
			- [x] Use previous traversal logic from search to find the node we want to delete, stop traversing once we find the node in the highest layer its in
			- [x] Store the bottom child, delete all references to the current node from neighbors and ArrayList layering system if necessary
			- [x] Repeat previous step until bottom child is null
		- [x] ReBalance
			- [x] Don’t call this automatically
			- [x] For every node in the bottom layer, regenerate its height
			- [x] Nuke every other layer
			- [x] Repopulate the linkedlists at the different layers based on the height of the node
		- [x] GrowHeight
			- [x] When the current number of layers as determined by the layering system increases, add a new head node to the ArrayList keeping track of the heads of every level
		- [x] ShrinkHeight
			- [x] When the current number of layers as determined by the layering system decreases, traverse the list of the highest head node
			- [x] Descend down a level at every node to remove references to this current top layer
			- [x] Update the layering system to reflect the shrinkage
	- [x] Implement a constructor that turns a payload into a SkipListSetItem
		- [x] Make sure we can access their internal compareTo methods
	- [x] Implement SkipListSetIterator for other programs to be able to use my skip list program
		- [x] Implement iterator in SkipListSetIterator
			- [x] hasNext
			- [x] next
			- [x] remove
		- [x] Return the payloads, not my SkipListSetItems
	- [x] Implement inherited SortedSet and Set methods in SkipListSet
		- [x] comparator
		- [x] subSet
		- [x] headSet
		- [x] tailSet
		- [x] first
		- [x] last
		- [x] size
		- [x] isEmpty
		- [x] contains
		- [x] iterator
		- [x] toArray()
		- [x] toArray(T1[] a)
		- [x] add
		- [x] remove
		- [x] containsAll
		- [x] addAll
		- [x] retainAll
		- [x] removeAll
		- [x] clear
		- [x] equals
		- [x] hashCode
	- [x] Ensure payload items implement Comparable
		- [x] Literally just part of SkipListSet’s class declaration 
	- [x] Create a constructor for an empty skip list
	- [x] Create a constructor for a skip list populated by the contents of a collection
	- [x] Create helper functions
		- [x] Traversal logic
		- [x] Compare two SkipListSetItems
		- [x] Setters and getters for internal SkipListSetItem variables
		- [x] Setters and getters for internal SkipListSetIterator variables
		- [x] Setters and getters for internal SkipListSet variables
		- [x] RandomHeightGenerator
	- [x] Create debugging functions
		- [x] Print out a node
		- [x] Print out a layer
		- [x] Print out the entire skip list
